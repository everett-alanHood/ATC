# -*- coding: utf-8 -*-
"""ATC_SIM_V52.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pSo_x5a3vHvQ2FiuWaOZ7kEAQ3arA2XP
"""

import pandas as pd
import csv
import time
from datetime import datetime, timedelta
import os
import json

class Airplane:
    def __init__(self, data):
        self.time = data.get('Time', '')
        self.hex = data.get('Hex', '')
        self.dist_to_gso = data.get('Distance to GSO', '')
        self.ds_type = data.get('DS Type', '')
        self.flight_number = data.get('Flight #', '')
        self.aircraft_reg = data.get('Aircraft_Reg', '')
        self.aircraft_type = data.get('Aircraft_Type', '')
        self.altitude_baro = data.get('Altitude Baro', '')
        self.altitude_geom = data.get('Altitude Geom', '')
        self.ground_speed = data.get('Ground Speed', '')
        self.track = data.get('Track', '')
        self.baro_rate = data.get('Baro Rate', '')
        self.squawk = data.get('Squawk', '')
        self.emergency = data.get('Emergency', '')
        self.category = data.get('Category', '')
        self.latitude = data.get('Latitude', '')
        self.longitude = data.get('Longitude', '')
        self.nic_navigation = data.get('NIC Navigation Integrity Category', '')
        self.rc_navigation = data.get('RC Navigation Accuracy Category', '')
        self.seen_position = data.get('Seen Position', '')
        self.version = data.get('Version', '')
        self.nic_baro = data.get('NIC Baro', '')
        self.nac_p = data.get('NAC P', '')
        self.nac_v = data.get('NAC V', '')
        self.sil_level = data.get('SIL Source Integrity Level ', '')
        self.sil_type = data.get('SIL Type', '')
        self.gva = data.get('GVA', '')
        self.sda = data.get('SDA System Design Assurance', '')
        self.alert = data.get('Alert', '')
        self.spi = data.get('SPI', '')
        self.mlat = data.get('MLAT', '')
        self.tisb = data.get('TISB', '')
        self.messages = data.get('Messages', '')
        self.seen = data.get('Seen', '')
        self.rssi = data.get('RSSI', '')

    def update_position(self, current_time, interval_seconds):
        if self.time:
            try:
                airplane_time = datetime.strptime(self.time, '%H%M%SZ')
                time_diff = abs((airplane_time - current_time).total_seconds())
                if time_diff <= interval_seconds:  # within the specified interval
                    print(f"Updating position for airplane with Hex: {self.hex} at time: {self.time}")
            except ValueError:
                pass

    def to_dict(self):
        return {
            "Time": self.time,
            "Hex": self.hex,
            "Distance to GSO": self.dist_to_gso,
            "Data Source Type": self.ds_type,
            "Flight Number": self.flight_number,
            "Aircraft Registration": self.aircraft_reg,
            "Aircraft Type": self.aircraft_type,
            "Altitude Barometric": self.altitude_baro,
            "Altitude Geometric": self.altitude_geom,
            "Ground Speed": self.ground_speed,
            "Track": self.track,
            "Barometric Rate": self.baro_rate,
            "Squawk Code": self.squawk,
            "Emergency": self.emergency,
            "Category": self.category,
            "Latitude": self.latitude,
            "Longitude": self.longitude,
            "NIC Navigation Integrity Category": self.nic_navigation,
            "RC Navigation Accuracy Category": self.rc_navigation,
            "Seen Position": self.seen_position,
            "Version": self.version,
            "NIC Baro": self.nic_baro,
            "NAC P": self.nac_p,
            "NAC V": self.nac_v,
            "SIL Source Integrity Level": self.sil_level,
            "SIL Type": self.sil_type,
            "GVA": self.gva,
            "SDA System Design Assurance": self.sda,
            "Alert": self.alert,
            "SPI": self.spi,
            "MLAT": self.mlat,
            "TISB": self.tisb,
            "Messages": self.messages,
            "Seen": self.seen,
            "RSSI": self.rssi
        }

class ATISTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class ApproachDepartureTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TOWERTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TranscriptionHandler:
    @staticmethod
    def get_transcriptions(airplane, transcriptions):
        transcription_texts = {
            'ATIS': [],
            'Approach/Departure': [],
            'TOWER': []
        }
        if airplane.time:
            try:
                airplane_time = datetime.strptime(airplane.time, '%H%M%SZ').time()
                for source, trans_list in transcriptions.items():
                    if trans_list and any(trans.start <= airplane_time <= trans.end for trans in trans_list):
                        transcription_texts[source].extend(t for t in trans_list if t.start <= airplane_time <= t.end)
            except ValueError:
                pass
        return transcription_texts

def load_transcriptions_from_csv(csv_files):
    # print(f"Loading transcriptions from {csv_files}...")
    transcriptions = {'ATIS': [], 'Approach/Departure': [], 'TOWER': []}
    for csv_file in csv_files:
        try:
            df = pd.read_csv(csv_file)
            for _, row in df.iterrows():
                start_time = datetime.strptime(row['Start'], '%H:%M:%S').time()
                end_time = datetime.strptime(row['End'], '%H:%M:%S').time()
                if 'ATIS' in row['Filename']:
                    transcriptions['ATIS'].append(ATISTranscription(row['Filename'], start_time, end_time, row['Transcription']))
                elif 'App-Dep' in row['Filename']:
                    transcriptions['Approach/Departure'].append(ApproachDepartureTranscription(row['Filename'], start_time, end_time, row['Transcription']))
                elif 'Twr' in row['Filename']:
                    transcriptions['TOWER'].append(TOWERTranscription(row['Filename'], start_time, end_time, row['Transcription']))
        except FileNotFoundError:
            print(f"File not found: {csv_file}")
    return transcriptions

def load_airplanes_from_csv(csv_file):
    # print(f"Loading airplanes from {csv_file}...")
    try:
        df = pd.read_csv(csv_file)
        return [Airplane(row) for _, row in df.iterrows()]
    except FileNotFoundError:
        print(f"File not found: {csv_file}")
        return []

def simulate_data_update(airplanes, current_time, interval_seconds):
    for airplane in airplanes:
        airplane.update_position(current_time, interval_seconds)

def write_snapshot_to_csv(airplanes, filename, output_path, transcriptions, interval_seconds, start_time, current_day_time):
    print(f"Writing snapshot to {output_path}/{filename}...")
    os.makedirs(output_path, exist_ok=True)  # Ensure output directory exists

    # Group airplanes by time
    grouped_airplanes = {}
    for airplane in airplanes:
        if airplane.time not in grouped_airplanes:
            grouped_airplanes[airplane.time] = []
        grouped_airplanes[airplane.time].append(airplane)

    # Flatten the dictionary to a sorted list of tuples
    sorted_airplanes = sorted(grouped_airplanes.items())

    # Calculate DT Time values based on the interval
    dt_times = [datetime.strptime(current_day_time, '%H%M%SZ') + timedelta(seconds=i * interval_seconds)
                for i in range(-1, 2)]  # Get one DT Time before, the current DT Time, and one DT Time after

    selected_rows = []
    for dt_time in dt_times:
        dt_time_str = dt_time.strftime('%H%M%SZ')
        for timestamp, airplanes_at_time in sorted_airplanes:
            if timestamp == dt_time_str:
                selected_rows.append((timestamp, airplanes_at_time))
                break
# ###
#     selected_rows = []
#     for dt_time in dt_times:
#         dt_time_str = dt_time.strftime('%H%M%SZ')
#         filtered_airplanes = {
#             'before': [],
#             'equal': [],
#             'after': []
#         }
#         for timestamp, airplanes_at_time in sorted_airplanes:
#             if timestamp < dt_time_str:
#                 filtered_airplanes['before'].extend(airplanes_at_time)
#             elif timestamp == dt_time_str:
#                 filtered_airplanes['equal'].extend(airplanes_at_time)
#             elif timestamp > dt_time_str:
#                 filtered_airplanes['after'].extend(airplanes_at_time)

#         # Add airplanes for the required rows
#         if filtered_airplanes['before']:
#             selected_rows.append(('Before', filtered_airplanes['before']))
#         if filtered_airplanes['equal']:
#             selected_rows.append(('Equal', filtered_airplanes['equal']))
#         if filtered_airplanes['after']:
#             selected_rows.append(('After', filtered_airplanes['after']))

# ####

    with open(f"{output_path}/{filename}", 'w', newline='') as csvfile:
        fieldnames = [
            'DT Time','Aircraft(Obj)',
            'ATIS Transcription Start', 'ATIS Transcription End', 'ATIS Transcription Text',
            'Approach/Departure Transcription Start', 'Approach/Departure Transcription End', 'Approach/Departure Transcription Text',
            'TOWER Transcription Start', 'TOWER Transcription End', 'TOWER Transcription Text'
        ]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        handler = TranscriptionHandler()
        start_datetime = datetime.strptime(start_time, '%H%M%SZ')

        for timestamp, airplanes_at_time in selected_rows:
            # Compute DT Time based on the current day time and intervals
            dt_time_str = timestamp

            # Collect transcriptions for each timestamp
            combined_transcriptions = {'ATIS': [], 'Approach/Departure': [], 'TOWER': []}
            for airplane in airplanes_at_time:
              transcriptions_for_airplane = handler.get_transcriptions(airplane, transcriptions)
              atis_transcription = transcriptions_for_airplane['ATIS'][0] if transcriptions_for_airplane['ATIS'] else None
              app_dep_transcription = transcriptions_for_airplane['Approach/Departure'][0] if transcriptions_for_airplane['Approach/Departure'] else None
              tower_transcription = transcriptions_for_airplane['TOWER'][0] if transcriptions_for_airplane['TOWER'] else None

            # Prepare row data
            row_data = {
                'DT Time': dt_time_str,
                # 'Aircraft(Obj)': ' | '.join(json.dumps(airplane.to_dict()) for airplane in airplanes_at_time),
                'Aircraft(Obj)': ' | '.join(json.dumps(airplane.to_dict()) for airplane in airplanes),
                # 'Aircraft(Obj)': airplane.hex,
                'ATIS Transcription Start': atis_transcription.start.strftime('%H:%M:%S') if atis_transcription else '',
                'ATIS Transcription End': atis_transcription.end.strftime('%H:%M:%S') if atis_transcription else '',
                'ATIS Transcription Text': atis_transcription.transcription_text if atis_transcription else '',
                'Approach/Departure Transcription Start': app_dep_transcription.start.strftime('%H:%M:%S') if app_dep_transcription else '',
                'Approach/Departure Transcription End': app_dep_transcription.end.strftime('%H:%M:%S') if app_dep_transcription else '',
                'Approach/Departure Transcription Text': app_dep_transcription.transcription_text if app_dep_transcription else '',
                'TOWER Transcription Start': tower_transcription.start.strftime('%H:%M:%S') if tower_transcription else '',
                'TOWER Transcription End': tower_transcription.end.strftime('%H:%M:%S') if tower_transcription else '',
                'TOWER Transcription Text': tower_transcription.transcription_text if tower_transcription else ''
            }

            writer.writerow(row_data)

def main():
    transcription_files = [
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/WAV2TXT_KGSO_ATIS_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/WAV2TXT_KGSO_Approach_Departure_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/WAV2TXT_KGSO_TOWER_reformatted.csv'
    ]

    # print("Loading transcriptions...")
    transcriptions = load_transcriptions_from_csv(transcription_files)

    csv_file = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/adsb_hist_06_01_24_cleaned.csv'
    # print("Loading airplanes...")
    airplanes = load_airplanes_from_csv(csv_file)

    start_time_str = input("Enter start time (e.g., 000000Z): ").strip()
    end_time_str = input("Enter end time (e.g., 010000Z): ").strip()
    interval_str = input("Enter time interval (e.g., 30s, 1m): ").strip()
    speed_str = input("Enter execution speed (e.g., 1.0 for normal speed): ").strip()
    current_day_time_str = input("Enter the current day time (e.g., 080000Z): ").strip()

    try:
        start_time = datetime.strptime(start_time_str, '%H%M%SZ')
        end_time = datetime.strptime(end_time_str, '%H%M%SZ')
        interval = int(interval_str[:-1])
        if interval_str[-1] == 'm':
            interval *= 60
        elif interval_str[-1] == 's':
            pass
        else:
            raise ValueError("Interval should be in 's' or 'm'.")
        speed = float(speed_str)
        current_day_time = datetime.strptime(current_day_time_str, '%H%M%SZ').strftime('%H%M%SZ')
        interval_seconds = interval

        time_points = [start_time + timedelta(seconds=i * interval) for i in range((end_time - start_time).seconds // interval + 1)]

        output_path = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data'

        for current_time in time_points:
            print(f"\nCurrent Simulation Time: {current_time.strftime('%H%M%SZ')}")
            filtered_airplanes = [
                airplane for airplane in airplanes
                if abs((datetime.strptime(airplane.time, '%H%M%SZ') - current_time).total_seconds()) <= interval_seconds
            ]

            simulate_data_update(filtered_airplanes, current_time, interval_seconds)

            for idx, airplane in enumerate(filtered_airplanes, 1):
                print(f"\nAirplane {idx}:")
                print(f"Time: {airplane.time}")
                print(f"Hex: {airplane.hex}")
                print(f"Distance to GSO: {airplane.dist_to_gso}")
                print(f"Data Source Type: {airplane.ds_type}")
                print(f"Flight Number: {airplane.flight_number}")
                print(f"Aircraft Registration: {airplane.aircraft_reg}")
                print(f"Aircraft Type: {airplane.aircraft_type}")
                print(f"Altitude Barometric: {airplane.altitude_baro}")
                print(f"Altitude Geometric: {airplane.altitude_geom}")
                print(f"Ground Speed: {airplane.ground_speed}")
                print(f"Track: {airplane.track}")
                print(f"Barometric Rate: {airplane.baro_rate}")
                print(f"Squawk Code: {airplane.squawk}")
                print(f"Emergency: {airplane.emergency}")
                print(f"Category: {airplane.category}")
                print(f"Latitude: {airplane.latitude}")
                print(f"Longitude: {airplane.longitude}")
                print(f"NIC Navigation Integrity Category: {airplane.nic_navigation}")
                print(f"RC Navigation Accuracy Category: {airplane.rc_navigation}")
                print(f"Seen Position: {airplane.seen_position}")
                print(f"Version: {airplane.version}")
                print(f"NIC Baro: {airplane.nic_baro}")
                print(f"NAC P: {airplane.nac_p}")
                print(f"NAC V: {airplane.nac_v}")
                print(f"SIL Source Integrity Level: {airplane.sil_level}")
                print(f"SIL Type: {airplane.sil_type}")
                print(f"GVA: {airplane.gva}")
                print(f"SDA System Design Assurance: {airplane.sda}")
                print(f"Alert: {airplane.alert}")
                print(f"SPI: {airplane.spi}")
                print(f"MLAT: {airplane.mlat}")
                print(f"TISB: {airplane.tisb}")
                print(f"Messages: {airplane.messages}")
                print(f"Seen: {airplane.seen}")
                print(f"RSSI: {airplane.rssi}")

                transcriptions_for_airplane = TranscriptionHandler.get_transcriptions(airplane, transcriptions)
                for source, texts in transcriptions_for_airplane.items():
                    for trans in texts:
                        print(f"\n{source} Transcription:")
                        print(f"Filename: {trans.filename}")
                        print(f"Start: {trans.start}")
                        print(f"End: {trans.end}")
                        print(f"Transcription: {trans.transcription_text}")

            if current_time.strftime('%H%M%SZ') == current_day_time:
                snapshot_file = f'final_snapshot_{current_day_time}.csv'
                write_snapshot_to_csv(filtered_airplanes, snapshot_file, output_path, transcriptions, interval_seconds, start_time_str, current_day_time)
                print(f"Snapshot saved to {output_path}/{snapshot_file}")
                break

            time.sleep(interval_seconds / speed)

    except ValueError as e:
        print(f"Error in input data: {e}")

    print("Simulation completed.")

if __name__ == "__main__":
    main()