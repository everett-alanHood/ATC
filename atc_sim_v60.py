# -*- coding: utf-8 -*-
"""ATC_SIM_V60.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RItEtp9o44SfEtnih2DfuqnwYwy1LTwK
"""

import pandas as pd
import csv
import time
from datetime import datetime, timedelta
import os
import json

# Class Definitions

class Airplane:
    def __init__(self, data):
        self.time = data.get('Time', '')
        self.hex = data.get('Hex', '')
        self.dist_to_gso = data.get('Distance to GSO', '')
        self.ds_type = data.get('Data Source Type', '')
        self.flight_number = data.get('Flight Number', '')
        self.aircraft_reg = data.get('Aircraft Registration', '')
        self.aircraft_type = data.get('Aircraft Type', '')
        self.altitude_baro = data.get('Altitude Barometric', '')
        self.altitude_geom = data.get('Altitude Geometric', '')
        self.ground_speed = data.get('Ground Speed', '')
        self.track = data.get('Track', '')
        self.baro_rate = data.get('Barometric Rate', '')
        self.squawk = data.get('Squawk Code', '')
        self.emergency = data.get('Emergency', '')
        self.category = data.get('Category', '')
        self.latitude = data.get('Latitude', '')
        self.longitude = data.get('Longitude', '')
        self.nic_navigation = data.get('NIC Navigation Integrity Category', '')
        self.rc_navigation = data.get('RC Navigation Accuracy Category', '')
        self.seen_position = data.get('Seen Position', '')
        self.version = data.get('Version', '')
        self.nic_baro = data.get('NIC Baro', '')
        self.nac_p = data.get('NAC P', '')
        self.nac_v = data.get('NAC V', '')
        self.sil_level = data.get('SIL Source Integrity Level', '')
        self.sil_type = data.get('SIL Type', '')
        self.gva = data.get('GVA', '')
        self.sda = data.get('SDA System Design Assurance', '')
        self.alert = data.get('Alert', '')
        self.spi = data.get('SPI', '')
        self.mlat = data.get('MLAT', '')
        self.tisb = data.get('TISB', '')
        self.messages = data.get('Messages', '')
        self.seen = data.get('Seen', '')
        self.rssi = data.get('RSSI', '')

    def to_dict(self):
        return {
            "Time": self.time,
            "Hex": self.hex,
            "Distance to GSO": self.dist_to_gso,
            "Data Source Type": self.ds_type,
            "Flight Number": self.flight_number,
            "Aircraft Registration": self.aircraft_reg,
            "Aircraft Type": self.aircraft_type,
            "Altitude Barometric": self.altitude_baro,
            "Altitude Geometric": self.altitude_geom,
            "Ground Speed": self.ground_speed,
            "Track": self.track,
            "Barometric Rate": self.baro_rate,
            "Squawk Code": self.squawk,
            "Emergency": self.emergency,
            "Category": self.category,
            "Latitude": self.latitude,
            "Longitude": self.longitude,
            "NIC Navigation Integrity Category": self.nic_navigation,
            "RC Navigation Accuracy Category": self.rc_navigation,
            "Seen Position": self.seen_position,
            "Version": self.version,
            "NIC Baro": self.nic_baro,
            "NAC P": self.nac_p,
            "NAC V": self.nac_v,
            "SIL Source Integrity Level": self.sil_level,
            "SIL Type": self.sil_type,
            "GVA": self.gva,
            "SDA System Design Assurance": self.sda,
            "Alert": self.alert,
            "SPI": self.spi,
            "MLAT": self.mlat,
            "TISB": self.tisb,
            "Messages": self.messages,
            "Seen": self.seen,
            "RSSI": self.rssi
        }

    def update_position(self, current_time, interval_seconds):
        """
        Update the position of the airplane based on the current simulation time and interval.
        """
        if self.time:
            try:
                airplane_time = datetime.strptime(self.time, '%H%M%SZ')
                time_diff = abs((airplane_time - current_time).total_seconds())
                if time_diff <= interval_seconds:  # within the specified interval
                    print(f"Updating position for airplane with Hex: {self.hex} at time: {self.time}")
            except ValueError:
                pass

class ATISTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class ApproachDepartureTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TOWERTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TranscriptionHandler:
    @staticmethod
    def get_transcriptions(airplane, transcriptions):
        transcription_texts = {
            'ATIS': [],
            'Approach/Departure': [],
            'TOWER': []
        }
        if airplane.time:
            try:
                airplane_time = datetime.strptime(airplane.time, '%H%M%SZ').time()
                for source, trans_list in transcriptions.items():
                    if trans_list and any(trans.start <= airplane_time <= trans.end for trans in trans_list):
                        transcription_texts[source].extend(t for t in trans_list if t.start <= airplane_time <= t.end)
            except ValueError:
                pass
        return transcription_texts

# Utility Functions

def load_transcriptions_from_csv(csv_files):
    transcriptions = {'ATIS': [], 'Approach/Departure': [], 'TOWER': []}
    for csv_file in csv_files:
        try:
            df = pd.read_csv(csv_file)
            for _, row in df.iterrows():
                start_time = datetime.strptime(row['Start'], '%H:%M:%S').time()
                end_time = datetime.strptime(row['End'], '%H:%M:%S').time()
                if 'ATIS' in row['Filename']:
                    transcriptions['ATIS'].append(ATISTranscription(row['Filename'], start_time, end_time, row['Transcription']))
                elif 'App-Dep' in row['Filename']:
                    transcriptions['Approach/Departure'].append(ApproachDepartureTranscription(row['Filename'], start_time, end_time, row['Transcription']))
                elif 'Twr' in row['Filename']:
                    transcriptions['TOWER'].append(TOWERTranscription(row['Filename'], start_time, end_time, row['Transcription']))
        except FileNotFoundError:
            print(f"File not found: {csv_file}")
    return transcriptions

def load_airplanes_from_csv(csv_file):
    try:
        df = pd.read_csv(csv_file)
        return [Airplane(row) for _, row in df.iterrows()]
    except FileNotFoundError:
        print(f"File not found: {csv_file}")
        return []

def simulate_data_update(airplanes, current_time, interval_seconds):
    for airplane in airplanes:
        airplane.update_position(current_time, interval_seconds)

def write_snapshot_to_csv(airplanes, filename, output_path, transcriptions, interval_seconds, start_time_str, end_time_str):
    print(f"Writing snapshot to {output_path}/{filename}...")
    os.makedirs(output_path, exist_ok=True)  # Ensure output directory exists

    start_datetime = datetime.strptime(start_time_str, '%H%M%SZ')
    end_datetime = datetime.strptime(end_time_str, '%H%M%SZ')

    # Generate all time intervals within the range
    time_intervals = [start_datetime + timedelta(seconds=i * interval_seconds) for i in range((end_datetime - start_datetime).seconds // interval_seconds + 1)]

    # Create a dictionary to store rows by time
    rows_by_time = {}

    for current_time in time_intervals:
        current_time_str = current_time.strftime('%H%M%SZ')
        filtered_airplanes = [airplane for airplane in airplanes if datetime.strptime(airplane.time, '%H%M%SZ') == current_time]

        # Initialize a row for this time if not already present
        if current_time_str not in rows_by_time:
            rows_by_time[current_time_str] = {
                'DT Time': current_time_str,
                'Aircraft(Obj)': 'None',
                'ATIS Transcription Start': 'None',
                'ATIS Transcription End': 'None',
                'ATIS Transcription Text': 'None',
                'Approach/Departure Transcription Start': 'None',
                'Approach/Departure Transcription End': 'None',
                'Approach/Departure Transcription Text': 'None',
                'TOWER Transcription Start': 'None',
                'TOWER Transcription End': 'None',
                'TOWER Transcription Text': 'None'
            }

        for airplane in filtered_airplanes:
            transcriptions_for_airplane = TranscriptionHandler.get_transcriptions(airplane, transcriptions)
            atis_transcription = transcriptions_for_airplane['ATIS'][0] if transcriptions_for_airplane['ATIS'] else None
            app_dep_transcription = transcriptions_for_airplane['Approach/Departure'][0] if transcriptions_for_airplane['Approach/Departure'] else None
            tower_transcription = transcriptions_for_airplane['TOWER'][0] if transcriptions_for_airplane['TOWER'] else None

            # Prepare row data
            row_data = {
                'DT Time': current_time_str,
                'Aircraft(Obj)': json.dumps(airplane.to_dict()),
                'ATIS Transcription Start': atis_transcription.start.strftime('%H:%M:%S') if atis_transcription else 'None',
                'ATIS Transcription End': atis_transcription.end.strftime('%H:%M:%S') if atis_transcription else 'None',
                'ATIS Transcription Text': atis_transcription.transcription_text if atis_transcription else 'None',
                'Approach/Departure Transcription Start': app_dep_transcription.start.strftime('%H:%M:%S') if app_dep_transcription else 'None',
                'Approach/Departure Transcription End': app_dep_transcription.end.strftime('%H:%M:%S') if app_dep_transcription else 'None',
                'Approach/Departure Transcription Text': app_dep_transcription.transcription_text if app_dep_transcription else 'None',
                'TOWER Transcription Start': tower_transcription.start.strftime('%H:%M:%S') if tower_transcription else 'None',
                'TOWER Transcription End': tower_transcription.end.strftime('%H:%M:%S') if tower_transcription else 'None',
                'TOWER Transcription Text': tower_transcription.transcription_text if tower_transcription else 'None',
            }

            rows_by_time[current_time_str].update(row_data)


    with open(f"{output_path}/{filename}", 'w', newline='') as csvfile:
        fieldnames = [
            'DT Time', 'Aircraft(Obj)',
            'ATIS Transcription Start', 'ATIS Transcription End', 'ATIS Transcription Text',
            'Approach/Departure Transcription Start', 'Approach/Departure Transcription End', 'Approach/Departure Transcription Text',
            'TOWER Transcription Start', 'TOWER Transcription End', 'TOWER Transcription Text'
        ]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for row in rows_by_time.values():
            writer.writerow(row)

# Main Execution

def main():
    transcription_files = [
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/WAV2TXT_KGSO_ATIS_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/WAV2TXT_KGSO_Approach_Departure_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/WAV2TXT_KGSO_TOWER_reformatted.csv'
    ]

    # Load transcriptions
    # print("Loading transcriptions...")
    transcriptions = load_transcriptions_from_csv(transcription_files)

    csv_file = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/adsb_hist_06_01_24_cleaned.csv'
    # Load airplanes
    # print("Loading airplanes...")
    airplanes = load_airplanes_from_csv(csv_file)

    start_time_str = input("Enter start time (e.g., 000000Z): ").strip()
    end_time_str = input("Enter end time (e.g., 010000Z): ").strip()
    interval_str = input("Enter time interval (e.g., 30s, 1m): ").strip()
    speed_str = input("Enter execution speed (e.g., 1.0 for normal speed): ").strip()

    try:
        start_time = datetime.strptime(start_time_str, '%H%M%SZ')
        end_time = datetime.strptime(end_time_str, '%H%M%SZ')
        interval = int(interval_str[:-1])
        if interval_str[-1] == 'm':
            interval *= 60
        elif interval_str[-1] == 's':
            pass
        else:
            raise ValueError("Interval should be in 's' or 'm'.")
        speed = float(speed_str)
        interval_seconds = interval

        time_points = [start_time + timedelta(seconds=i * interval) for i in range((end_time - start_time).seconds // interval + 1)]

        output_path = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data'
        all_filtered_airplanes = []

        for current_time in time_points:
            print(f"\nCurrent Simulation Time: {current_time.strftime('%H%M%SZ')}")
            filtered_airplanes = [
                airplane for airplane in airplanes
                if abs((datetime.strptime(airplane.time, '%H%M%SZ') - current_time).total_seconds()) <= interval_seconds
            ]

            simulate_data_update(filtered_airplanes, current_time, interval_seconds)
            all_filtered_airplanes.extend(filtered_airplanes)  # Collect data

            # Optional: print details of airplanes for current time
            for idx, airplane in enumerate(filtered_airplanes, 1):
                print(f"\nAirplane {idx}:")
                print(f"Time: {airplane.time}")
                print(f"Hex: {airplane.hex}")
                print(f"Distance to GSO: {airplane.dist_to_gso}")
                print(f"Data Source Type: {airplane.ds_type}")
                print(f"Flight Number: {airplane.flight_number}")
                print(f"Aircraft Registration: {airplane.aircraft_reg}")
                print(f"Aircraft Type: {airplane.aircraft_type}")
                print(f"Altitude Barometric: {airplane.altitude_baro}")
                print(f"Altitude Geometric: {airplane.altitude_geom}")
                print(f"Ground Speed: {airplane.ground_speed}")
                print(f"Track: {airplane.track}")
                print(f"Barometric Rate: {airplane.baro_rate}")
                print(f"Squawk Code: {airplane.squawk}")
                print(f"Emergency: {airplane.emergency}")
                print(f"Category: {airplane.category}")
                print(f"Latitude: {airplane.latitude}")
                print(f"Longitude: {airplane.longitude}")
                print(f"NIC Navigation Integrity Category: {airplane.nic_navigation}")
                print(f"RC Navigation Accuracy Category: {airplane.rc_navigation}")
                print(f"Seen Position: {airplane.seen_position}")
                print(f"Version: {airplane.version}")
                print(f"NIC Baro: {airplane.nic_baro}")
                print(f"NAC P: {airplane.nac_p}")
                print(f"NAC V: {airplane.nac_v}")
                print(f"SIL Source Integrity Level: {airplane.sil_level}")
                print(f"SIL Type: {airplane.sil_type}")
                print(f"GVA: {airplane.gva}")
                print(f"SDA System Design Assurance: {airplane.sda}")
                print(f"Alert: {airplane.alert}")
                print(f"SPI: {airplane.spi}")
                print(f"MLAT: {airplane.mlat}")
                print(f"TISB: {airplane.tisb}")
                print(f"Messages: {airplane.messages}")
                print(f"Seen: {airplane.seen}")
                print(f"RSSI: {airplane.rssi}")

                transcriptions_for_airplane = TranscriptionHandler.get_transcriptions(airplane, transcriptions)
                for source, texts in transcriptions_for_airplane.items():
                    for trans in texts:
                        print(f"\n{source} Transcription:")
                        print(f"Filename: {trans.filename}")
                        print(f"Start: {trans.start}")
                        print(f"End: {trans.end}")
                        print(f"Transcription: {trans.transcription_text}")

            time.sleep(interval_seconds / speed)

        # Save the final snapshot after the simulation
        snapshot_file = 'snapshot_final.csv'
        write_snapshot_to_csv(all_filtered_airplanes, snapshot_file, output_path, transcriptions, interval_seconds, start_time_str, end_time_str)
        print(f"Final snapshot saved to {output_path}/{snapshot_file}")

    except ValueError as e:
        print(f"Error in input data: {e}")

    print("Simulation completed.")

if __name__ == "__main__":
    main()

