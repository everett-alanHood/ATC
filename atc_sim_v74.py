# -*- coding: utf-8 -*-
"""ATC_SIM_V74.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q_tF-OqpbMx98H3P9hnZyjSV4MaG2Yk1
"""

import pandas as pd
import csv
import time
from datetime import datetime, timedelta
import os
import json

# Class Definitions

class Airplane:
    previous_positions = {}  # Class-level dictionary to store previous positions for airspace status

    def __init__(self, data):
        self.time = data.get('Time', '')
        self.hex = data.get('Hex', '')
        self.dist_to_gso = data.get('Distance to GSO', '')
        self.ds_type = data.get('DS Type', '')
        self.flight_number = data.get('Flight #', '')
        self.aircraft_reg = data.get('Aircraft_Reg', '')
        self.aircraft_type = data.get('Aircraft_Type', '')
        self.altitude_baro = data.get('Altitude Baro', '')
        self.altitude_geom = data.get('Altitude Geom', '')
        self.ground_speed = data.get('Ground Speed', '')
        self.track = data.get('Track', '')
        self.baro_rate = data.get('Baro Rate', '')
        self.squawk = data.get('Squawk', '')
        self.emergency = data.get('Emergency', '')
        self.category = data.get('Category', '')
        self.latitude = float(data.get('Latitude', '0'))
        self.longitude = float(data.get('Longitude', '0'))
        self.nic_navigation = data.get('NIC Navigation Integrity Category', '')
        self.rc_navigation = data.get('RC Navigation Accuracy Category', '')
        self.seen_position = data.get('Seen Position', '')
        self.version = data.get('Version', '')
        self.nic_baro = data.get('NIC Baro', '')
        self.nac_p = data.get('NAC P', '')
        self.nac_v = data.get('NAC V', '')
        self.sil_level = data.get('SIL Source Integrity Level ', '')
        self.sil_type = data.get('SIL Type', '')
        self.gva = data.get('GVA', '')
        self.sda = data.get('SDA System Design Assurance', '')
        self.alert = data.get('Alert', '')
        self.spi = data.get('SPI', '')
        self.mlat = data.get('MLAT', '')
        self.tisb = data.get('TISB', '')
        self.messages = data.get('Messages', '')
        self.seen = data.get('Seen', '')
        self.rssi = data.get('RSSI', '')

        # Initialization of airspace status
        self.a_statt = self.determine_airspace_status()

        # For updating previous positions for tracking movement for airspace status
        Airplane.previous_positions[self.hex] = {
            'latitude': self.latitude,
            'longitude': self.longitude,
            'altitude_geom': self.altitude_geom,
            'altitude_baro': self.altitude_baro
        }

    def determine_airspace_status(self):
        try:
            lat = float(self.latitude) if self.latitude else 0.0
            lon = float(self.longitude) if self.longitude else 0.0
        except ValueError:
            lat = 0.0
            lon = 0.0

        try:
            altitude_geom = float(self.altitude_geom) if self.altitude_geom else 0.0
        except ValueError:
            altitude_geom = 0.0

        # Handle altitude_baro separately to avoid conversion errors
        altitude_baro = self.altitude_baro
        if altitude_baro != 'ground':
            try:
                altitude_baro = float(altitude_baro)
            except ValueError:
                altitude_baro = 0.0  # Default value in case of conversion failure

        try:
            ground_speed = float(self.ground_speed) if self.ground_speed else 0.0
        except ValueError:
            ground_speed = 0.0

        # Get previous position for the aircraft, if available
        previous_position = Airplane.previous_positions.get(self.hex, {})
        prev_lat = float(previous_position.get('latitude', 0.0))
        prev_lon = float(previous_position.get('longitude', 0.0))
        prev_altitude_geom = float(previous_position.get('altitude_geom', 0.0))
        prev_altitude_baro = previous_position.get('altitude_baro', '0.0')

        # Handle prev_altitude_baro separately
        if prev_altitude_baro != 'ground':
            try:
                prev_altitude_baro = float(prev_altitude_baro)
            except ValueError:
                prev_altitude_baro = 0.0

        # Determine status based on location, altitude, and previous positions
        if 30.0 < lat < 35.0 and -80.0 < lon < -75.0:
            return 'Arriving'
        elif 25.0 < lat < 30.0 and -85.0 < lon < -80.0:
            return 'Departing'
        elif altitude_geom > 10000:
            return 'Passing'
        elif ground_speed > 0 and altitude_geom == 0:
            return 'Taxiing'
        elif altitude_baro == 'ground' or (lat == prev_lat and lon == prev_lon and altitude_geom == prev_altitude_geom):
            return 'Grounded/Parked'  # Combine conditions for grounded/parked and stationary
        else:
            return 'Unknown'

    def to_dict(self):
        return {
            "Time": self.time,
            "Hex": self.hex,
            "Distance to GSO": self.dist_to_gso,
            "Airspace Status": self.a_statt,  # Include airspace status in the dict
            "Data Source Type": self.ds_type,
            "Flight Number": self.flight_number,
            "Aircraft Registration": self.aircraft_reg,
            "Aircraft Type": self.aircraft_type,
            "Altitude Barometric": self.altitude_baro,
            "Altitude Geometric": self.altitude_geom,
            "Ground Speed": self.ground_speed,
            "Track": self.track,
            "Barometric Rate": self.baro_rate,
            "Squawk Code": self.squawk,
            "Emergency": self.emergency,
            "Category": self.category,
            "Latitude": self.latitude,
            "Longitude": self.longitude,
            "NIC Navigation Integrity Category": self.nic_navigation,
            "RC Navigation Accuracy Category": self.rc_navigation,
            "Seen Position": self.seen_position,
            "Version": self.version,
            "NIC Baro": self.nic_baro,
            "NAC P": self.nac_p,
            "NAC V": self.nac_v,
            "SIL Source Integrity Level": self.sil_level,
            "SIL Type": self.sil_type,
            "GVA": self.gva,
            "SDA System Design Assurance": self.sda,
            "Alert": self.alert,
            "SPI": self.spi,
            "MLAT": self.mlat,
            "TISB": self.tisb,
            "Messages": self.messages,
            "Seen": self.seen,
            "RSSI": self.rssi
        }

    def update_position(self, current_time, interval_seconds, nw_data):
        # Update the previous position in the class-level dictionary
        Airplane.previous_positions[self.hex] = {
            'latitude': self.latitude,
            'longitude': self.longitude,
            'altitude_geom': self.altitude_geom,
            'altitude_baro': self.altitude_baro
        }

        # Update the attributes with new data
        self.latitude = nw_data.get('latitude', self.latitude)
        self.longitude = nw_data.get('longitude', self.longitude)
        self.altitude_geom = nw_data.get('altitude_geom', self.altitude_geom)
        self.altitude_baro = nw_data.get('altitude_baro', self.altitude_baro)
        self.ground_speed = nw_data.get('ground_speed', self.ground_speed)

        # Recalculate airspace status
        self.a_statt = self.determine_airspace_status()

        # Simulated Positioning based on airplane_Time
        if self.time:
            try:
                airplane_time = datetime.strptime(self.time, '%H%M%SZ')
                time_diff = abs((airplane_time - current_time).total_seconds())
                if time_diff <= interval_seconds:
                    print(f"Updating position for airplane with Hex: {self.hex} at time: {self.time}")
            except ValueError:
                pass

class ATISTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class ApproachDepartureTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TOWERTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TranscriptionHandler:
    @staticmethod
    def get_transcriptions(airplane, transcriptions):
        transcription_texts = {
            'ATIS': [],
            'Approach/Departure': [],
            'TOWER': []
        }
        if airplane.time:
            try:
                airplane_time = datetime.strptime(airplane.time, '%H%M%SZ').time()
                for source, trans_list in transcriptions.items():
                    transcription_texts[source] = [t for t in trans_list if t.start <= airplane_time <= t.end]
            except ValueError:
                pass
        return transcription_texts

# Utility Functions

def load_transcriptions_from_csv(files):
    transcriptions = {
        'ATIS': [],
        'Approach/Departure': [],
        'TOWER': []
    }

    for file in files:
        source_type = {
            'KGSO_ATIS': 'ATIS',
            'KGSO_Approach_Departure': 'Approach/Departure',
            'KGSO_TOWER': 'TOWER'
        }
        source = next((key for key in source_type if key in file), None)
        if source:
            source_type_value = source_type[source]
            with open(file, 'r') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    start = datetime.strptime(row['Start'], '%H:%M:%S').time()
                    end = datetime.strptime(row['End'], '%H:%M:%S').time()
                    transcription_text = row['Transcription']
                    trans_class = {
                        'ATIS': ATISTranscription,
                        'Approach/Departure': ApproachDepartureTranscription,
                        'TOWER': TOWERTranscription
                    }[source_type_value]
                    transcriptions[source_type_value].append(trans_class(file, start, end, transcription_text))
    return transcriptions

def load_airplanes_from_csv(file):
    airplanes = []
    df = pd.read_csv(file)
    for _, row in df.iterrows():
        airplanes.append(Airplane(row.to_dict()))
    return airplanes

def simulate_data_update(filtered_airplanes, current_time, interval_seconds, n_data):
    for airplane in filtered_airplanes:
        airplane.update_position(current_time, interval_seconds, n_data)


def write_snapshot_to_csv(airplanes, filename, output_path, transcriptions, interval_seconds, start_time_str, end_time_str):
    print(f"Writing snapshot to {output_path}/{filename}...")
    os.makedirs(output_path, exist_ok=True)  # Ensure output directory exists

    start_datetime = datetime.strptime(start_time_str, '%H%M%SZ')
    end_datetime = datetime.strptime(end_time_str, '%H%M%SZ')

    # Generate all time intervals within the range
    time_intervals = [start_datetime + timedelta(seconds=i * interval_seconds) for i in range((end_datetime - start_datetime).seconds // interval_seconds + 1)]

    # Create a dictionary to store rows by time
    rows_by_time = {}

    for current_time in time_intervals:
        current_time_str = current_time.strftime('%H%M%SZ')
        time_range_start = current_time - timedelta(seconds=interval_seconds)
        time_range_end = current_time + timedelta(seconds=interval_seconds)

        filtered_airplanes = [airplane for airplane in airplanes if time_range_start <= datetime.strptime(airplane.time, '%H%M%SZ') <= time_range_end]

        # Initialize a row for this time if not already present
        if current_time_str not in rows_by_time:
            rows_by_time[current_time_str] = {
                'DT Time': current_time_str,
                'Aircraft(Obj)': [],
                'ATIS Transcription Start': 'None',
                'ATIS Transcription End': 'None',
                'ATIS Transcription Text': 'None',
                'Approach/Departure Transcription Start': 'None',
                'Approach/Departure Transcription End': 'None',
                'Approach/Departure Transcription Text': 'None',
                'TOWER Transcription Start': 'None',
                'TOWER Transcription End': 'None',
                'TOWER Transcription Text': 'None'
            }

        # Add data for each airplane, ensuring no duplicate entries
        for airplane in filtered_airplanes:
            existing_airplane = next((item for item in rows_by_time[current_time_str]['Aircraft(Obj)'] if item['Hex'] == airplane.hex), None)
            if not existing_airplane:
                rows_by_time[current_time_str]['Aircraft(Obj)'].append(airplane.to_dict())

        # Collect transcriptions for the current time
        transcriptions_for_time = {source: [] for source in ['ATIS', 'Approach/Departure', 'TOWER']}
        for source, trans_list in transcriptions.items():
            transcriptions_for_time[source] = [t for t in trans_list if t.start <= datetime.strptime(current_time_str, '%H%M%SZ').time() <= t.end]

        # Fill transcription data for this time slot
        for source in transcriptions_for_time:
            if transcriptions_for_time[source]:
                trans = transcriptions_for_time[source][0]  # Take the first transcription for this time
                if source == 'ATIS':
                    rows_by_time[current_time_str]['ATIS Transcription Start'] = str(trans.start)
                    rows_by_time[current_time_str]['ATIS Transcription End'] = str(trans.end)
                    rows_by_time[current_time_str]['ATIS Transcription Text'] = f'"{trans.transcription_text}"'
                elif source == 'Approach/Departure':
                    rows_by_time[current_time_str]['Approach/Departure Transcription Start'] = str(trans.start)
                    rows_by_time[current_time_str]['Approach/Departure Transcription End'] = str(trans.end)
                    rows_by_time[current_time_str]['Approach/Departure Transcription Text'] = f'"{trans.transcription_text}"'
                elif source == 'TOWER':
                    rows_by_time[current_time_str]['TOWER Transcription Start'] = str(trans.start)
                    rows_by_time[current_time_str]['TOWER Transcription End'] = str(trans.end)
                    rows_by_time[current_time_str]['TOWER Transcription Text'] = f'"{trans.transcription_text}"'

    # Write to CSV
    with open(os.path.join(output_path, filename), 'w', newline='') as file:
        writer = csv.writer(file, quotechar='"', quoting=csv.QUOTE_MINIMAL)
        headers = [
            'DT Time',
            'Aircraft(Obj)',
            'ATIS Transcription Start',
            'ATIS Transcription End',
            'ATIS Transcription Text',
            'Approach/Departure Transcription Start',
            'Approach/Departure Transcription End',
            'Approach/Departure Transcription Text',
            'TOWER Transcription Start',
            'TOWER Transcription End',
            'TOWER Transcription Text'
        ]
        writer.writerow(headers)  # Write header

        # Track previous transcription data
        previous_transcriptions = {
            'Aircraft(Obj)': '[]',
            'ATIS Transcription Start': 'None',
            'ATIS Transcription End': 'None',
            'ATIS Transcription Text': 'None',
            'Approach/Departure Transcription Start': 'None',
            'Approach/Departure Transcription End': 'None',
            'Approach/Departure Transcription Text': 'None',
            'TOWER Transcription Start': 'None',
            'TOWER Transcription End': 'None',
            'TOWER Transcription Text': 'None'
        }

        for i, time_key in enumerate(sorted(rows_by_time.keys())):
            data = rows_by_time[time_key]

            # If it's the first row, leave transcription fields as default
            if i == 0:
                row = [
                    data['DT Time'],
                    # json.dumps(previous_transcriptions['Aircraft(Obj)']),
                    str(previous_transcriptions['Aircraft(Obj)']),
                    previous_transcriptions['ATIS Transcription Start'],
                    previous_transcriptions['ATIS Transcription End'],
                    previous_transcriptions['ATIS Transcription Text'],
                    previous_transcriptions['Approach/Departure Transcription Start'],
                    previous_transcriptions['Approach/Departure Transcription End'],
                    previous_transcriptions['Approach/Departure Transcription Text'],
                    previous_transcriptions['TOWER Transcription Start'],
                    previous_transcriptions['TOWER Transcription End'],
                    previous_transcriptions['TOWER Transcription Text']
                ]
            else:
                # Update transcription data for this row
                row = [
                    data['DT Time'],
                    # json.dumps(previous_transcriptions['Aircraft(Obj)']),
                    str(previous_transcriptions['Aircraft(Obj)']),
                    previous_transcriptions['ATIS Transcription Start'],
                    previous_transcriptions['ATIS Transcription End'],
                    previous_transcriptions['ATIS Transcription Text'],
                    previous_transcriptions['Approach/Departure Transcription Start'],
                    previous_transcriptions['Approach/Departure Transcription End'],
                    previous_transcriptions['Approach/Departure Transcription Text'],
                    previous_transcriptions['TOWER Transcription Start'],
                    previous_transcriptions['TOWER Transcription End'],
                    previous_transcriptions['TOWER Transcription Text']
                ]

            writer.writerow(row)

            # Update previous transcription data for the next row
            previous_transcriptions.update({
                'Aircraft(Obj)': data['Aircraft(Obj)'],
                'ATIS Transcription Start': data['ATIS Transcription Start'],
                'ATIS Transcription End': data['ATIS Transcription End'],
                'ATIS Transcription Text': data['ATIS Transcription Text'],
                'Approach/Departure Transcription Start': data['Approach/Departure Transcription Start'],
                'Approach/Departure Transcription End': data['Approach/Departure Transcription End'],
                'Approach/Departure Transcription Text': data['Approach/Departure Transcription Text'],
                'TOWER Transcription Start': data['TOWER Transcription Start'],
                'TOWER Transcription End': data['TOWER Transcription End'],
                'TOWER Transcription Text': data['TOWER Transcription Text']
            })


# Main Execution

def main():
    transcription_files = [
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/new_freq_filesWAV2TXT - KGSO_ATIS 2_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/new_freq_filesWAV2TXT - KGSO_Approach_Departure 2_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/new_freq_filesWAV2TXT - KGSO_TOWER 2_reformatted.csv'
    ]

    # Load transcriptions
    transcriptions = load_transcriptions_from_csv(transcription_files)

    csv_file = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/adsb_hist_06_01_24_cleaned.csv'
    # Load airplanes
    airplanes = load_airplanes_from_csv(csv_file)

    start_time_str = input("Enter start time (e.g., 000000Z): ").strip()
    end_time_str = input("Enter end time (e.g., 010000Z): ").strip()
    interval_str = input("Enter time interval (e.g., 30s, 1m): ").strip()
    speed_str = input("Enter execution speed (e.g., 1.0 for normal speed): ").strip()

    try:
        start_time = datetime.strptime(start_time_str, '%H%M%SZ')
        end_time = datetime.strptime(end_time_str, '%H%M%SZ')
        interval = int(interval_str[:-1])
        if interval_str[-1] == 'm':
            interval *= 60
        elif interval_str[-1] == 's':
            pass
        else:
            raise ValueError("Interval should be in 's' or 'm'.")
        speed = float(speed_str)
        interval_seconds = interval

        time_points = [start_time + timedelta(seconds=i * interval) for i in range((end_time - start_time).seconds // interval + 1)]

        output_path = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data'
        all_filtered_airplanes = []

        for current_time in time_points:
            print(f"\nCurrent Simulation Time: {current_time.strftime('%H%M%SZ')}")
            filtered_airplanes = [
                airplane for airplane in airplanes
                if abs((datetime.strptime(airplane.time, '%H%M%SZ') - current_time).total_seconds()) <= interval_seconds
            ]

            # Example of updating the n_data per airplane instance
            for airplane in filtered_airplanes:
                n_data = {
                    'latitude': airplane.latitude,
                    'longitude': airplane.longitude,
                    'altitude_geom': airplane.altitude_geom,
                    'altitude_baro': airplane.altitude_baro,
                    'ground_speed': airplane.ground_speed
                }

                simulate_data_update([airplane], current_time, interval_seconds, n_data)

            all_filtered_airplanes.extend(filtered_airplanes)  # Collect data

            # Optional: print details of airplanes for current time
            for idx, airplane in enumerate(filtered_airplanes, 1):
                print(f"\nAirplane {idx}:")
                print(f"Time: {airplane.time}")
                print(f"Hex: {airplane.hex}")
                print(f"Distance to GSO: {airplane.dist_to_gso}")
                print(f"Data Source Type: {airplane.ds_type}")
                print(f"Flight Number: {airplane.flight_number}")
                print(f"Aircraft Registration: {airplane.aircraft_reg}")
                print(f"Aircraft Type: {airplane.aircraft_type}")
                print(f"Altitude Barometric: {airplane.altitude_baro}")
                print(f"Altitude Geometric: {airplane.altitude_geom}")
                print(f"Ground Speed: {airplane.ground_speed}")
                print(f"Track: {airplane.track}")
                print(f"Barometric Rate: {airplane.baro_rate}")
                print(f"Squawk Code: {airplane.squawk}")
                print(f"Emergency: {airplane.emergency}")
                print(f"Category: {airplane.category}")
                print(f"Latitude: {airplane.latitude}")
                print(f"Longitude: {airplane.longitude}")
                print(f"NIC Navigation Integrity Category: {airplane.nic_navigation}")
                print(f"RC Navigation Accuracy Category: {airplane.rc_navigation}")
                print(f"Seen Position: {airplane.seen_position}")
                print(f"Version: {airplane.version}")
                print(f"NIC Baro: {airplane.nic_baro}")
                print(f"NAC P: {airplane.nac_p}")
                print(f"NAC V: {airplane.nac_v}")
                print(f"SIL Source Integrity Level: {airplane.sil_level}")
                print(f"SIL Type: {airplane.sil_type}")
                print(f"GVA: {airplane.gva}")
                print(f"SDA System Design Assurance: {airplane.sda}")
                print(f"Alert: {airplane.alert}")
                print(f"SPI: {airplane.spi}")
                print(f"MLAT: {airplane.mlat}")
                print(f"TISB: {airplane.tisb}")
                print(f"Messages: {airplane.messages}")
                print(f"Seen: {airplane.seen}")
                print(f"RSSI: {airplane.rssi}")

                transcriptions_for_airplane = TranscriptionHandler.get_transcriptions(airplane, transcriptions)
                for source, texts in transcriptions_for_airplane.items():
                    for trans in texts:
                        print(f"\n{source} Transcription:")
                        print(f"Filename: {trans.filename}")
                        print(f"Start: {trans.start}")
                        print(f"End: {trans.end}")
                        print(f"Transcription: {trans.transcription_text}")

            time.sleep(interval_seconds / speed)

        # Save the final snapshot after the simulation
        snapshot_file = 'snapshot_final.csv'
        write_snapshot_to_csv(all_filtered_airplanes, snapshot_file, output_path, transcriptions, interval_seconds, start_time_str, end_time_str)
        print(f"Final snapshot saved to {output_path}/{snapshot_file}")

    except ValueError as e:
        print(f"Error in input data: {e}")

    print("Simulation completed.")

if __name__ == "__main__":
    main()