# -*- coding: utf-8 -*-
"""ATC_SIM_V80.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X_yqyqL8DCl-Z8wU-nK0rvBjdGXkyvdK
"""

import pandas as pd
import csv
import time
from datetime import datetime, timedelta
import os
import json

# Class Definitions

class Airplane:
    def __init__(self, data):
        self.time = data.get('Time', '')
        self.hex = data.get('Hex', '')
        self.dist_to_gso = data.get('Distance to GSO', '')
        self.ds_type = data.get('DS Type', '')
        self.flight_number = data.get('Flight #', '')
        self.aircraft_reg = data.get('Aircraft_Reg', '')
        self.aircraft_type = data.get('Aircraft_Type', '')
        self.altitude_baro = data.get('Altitude Baro', '')
        self.altitude_geom = data.get('Altitude Geom', '')
        self.ground_speed = data.get('Ground Speed', '')
        self.track = data.get('Track', '')
        self.baro_rate = data.get('Baro Rate', '')
        self.squawk = data.get('Squawk', '')
        self.emergency = data.get('Emergency', '')
        self.category = data.get('Category', '')
        self.latitude = float(data.get('Latitude', '0'))
        self.longitude = float(data.get('Longitude', '0'))
        self.nic_navigation = data.get('NIC Navigation Integrity Category', '')
        self.rc_navigation = data.get('RC Navigation Accuracy Category', '')
        self.seen_position = data.get('Seen Position', '')
        self.version = data.get('Version', '')
        self.nic_baro = data.get('NIC Baro', '')
        self.nac_p = data.get('NAC P', '')
        self.nac_v = data.get('NAC V', '')
        self.sil_level = data.get('SIL Source Integrity Level ', '')
        self.sil_type = data.get('SIL Type', '')
        self.gva = data.get('GVA', '')
        self.sda = data.get('SDA System Design Assurance', '')
        self.alert = data.get('Alert', '')
        self.spi = data.get('SPI', '')
        self.mlat = data.get('MLAT', '')
        self.tisb = data.get('TISB', '')
        self.messages = data.get('Messages', '')
        self.seen = data.get('Seen', '')
        self.rssi = data.get('RSSI', '')

        # Initialization of airspace status
        self.a_statt = self.determine_airspace_status()


    def determine_airspace_status(self):
        try:
            lat = float(self.latitude) if self.latitude else 0.0
            lon = float(self.longitude) if self.longitude else 0.0
        except ValueError:
            lat = 0.0
            lon = 0.0

        try:
            altitude_geom = float(self.altitude_geom) if self.altitude_geom else 0.0
        except ValueError:
            altitude_geom = 0.0

        try:
            altitude_baro = float(self.altitude_baro) if self.altitude_baro else 0.0
        except ValueError:
            altitude_baro = 0.0

        try:
            ground_speed = float(self.ground_speed) if self.ground_speed else 0.0
        except ValueError:
            ground_speed = 0.0

        # Determine status based on location and altitude
        if 30.0 < lat < 35.0 and -80.0 < lon < -75.0:
            return 'Arriving'
        elif 25.0 < lat < 30.0 and -85.0 < lon < -80.0:
            return 'Departing'
        elif altitude_geom > 10000:
            return 'Passing'
        elif ground_speed > 0 and altitude_geom == 0:
            return 'Taxiing'
        elif self.altitude_baro == 'ground':  # Check if altitude_baro equals the string 'ground'
            return 'Grounded/Parked'
        else:
            return 'Unknown'



    def to_dict(self):
        return {
            "Time": self.time,
            "Hex": self.hex,
            "Distance to GSO": self.dist_to_gso,
            "Airspace Status": self.a_statt,  # Include airspace status in the dict
            "Data Source Type": self.ds_type,
            "Flight Number": self.flight_number,
            "Aircraft Registration": self.aircraft_reg,
            "Aircraft Type": self.aircraft_type,
            "Altitude Barometric": self.altitude_baro,
            "Altitude Geometric": self.altitude_geom,
            "Ground Speed": self.ground_speed,
            "Track": self.track,
            "Barometric Rate": self.baro_rate,
            "Squawk Code": self.squawk,
            "Emergency": self.emergency,
            "Category": self.category,
            "Latitude": self.latitude,
            "Longitude": self.longitude,
            "NIC Navigation Integrity Category": self.nic_navigation,
            "RC Navigation Accuracy Category": self.rc_navigation,
            "Seen Position": self.seen_position,
            "Version": self.version,
            "NIC Baro": self.nic_baro,
            "NAC P": self.nac_p,
            "NAC V": self.nac_v,
            "SIL Source Integrity Level": self.sil_level,
            "SIL Type": self.sil_type,
            "GVA": self.gva,
            "SDA System Design Assurance": self.sda,
            "Alert": self.alert,
            "SPI": self.spi,
            "MLAT": self.mlat,
            "TISB": self.tisb,
            "Messages": self.messages,
            "Seen": self.seen,
            "RSSI": self.rssi
        }

    def update_position(self, current_time, interval_seconds):
        if self.time:
            try:
                airplane_time = datetime.strptime(self.time, '%H%M%SZ')
                time_diff = abs((airplane_time - current_time).total_seconds())
                if time_diff <= interval_seconds:
                    print(f"Updating position for airplane with Hex: {self.hex} at time: {self.time}")
            except ValueError:
                pass

class ATISTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class ApproachDepartureTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TOWERTranscription:
    def __init__(self, filename, start, end, transcription_text):
        self.filename = filename
        self.start = start
        self.end = end
        self.transcription_text = transcription_text

class TranscriptionHandler:
    @staticmethod
    def get_transcriptions(airplane, transcriptions):
        transcription_texts = {
            'ATIS': [],
            'Approach/Departure': [],
            'TOWER': []
        }
        if airplane.time:
            try:
                airplane_time = datetime.strptime(airplane.time, '%H%M%SZ').time()
                for source, trans_list in transcriptions.items():
                    transcription_texts[source] = [t for t in trans_list if t.start <= airplane_time <= t.end]
            except ValueError:
                pass
        return transcription_texts

# Utility Functions

def load_transcriptions_from_csv(csv_files):
    transcriptions = {'ATIS': [], 'Approach/Departure': [], 'TOWER': []}
    for csv_file in csv_files:
        try:
            df = pd.read_csv(csv_file)
            for _, row in df.iterrows():
                start_time = datetime.strptime(row['Start'], '%H:%M:%S').time()
                end_time = datetime.strptime(row['End'], '%H:%M:%S').time()
                if 'ATIS' in row['Filename']:
                    transcriptions['ATIS'].append(ATISTranscription(row['Filename'], start_time, end_time, row['Transcription']))
                elif 'App-Dep' in row['Filename']:
                    transcriptions['Approach/Departure'].append(ApproachDepartureTranscription(row['Filename'], start_time, end_time, row['Transcription']))
                elif 'Twr' in row['Filename']:
                    transcriptions['TOWER'].append(TOWERTranscription(row['Filename'], start_time, end_time, row['Transcription']))
        except FileNotFoundError:
            print(f"File not found: {csv_file}")
    return transcriptions

def load_airplanes_from_csv(csv_file):
    try:
        df = pd.read_csv(csv_file)
        return [Airplane(row) for _, row in df.iterrows()]
    except FileNotFoundError:
        print(f"File not found: {csv_file}")
        return []

def simulate_data_update(airplanes, current_time, interval_seconds):
    for airplane in airplanes:
        airplane.update_position(current_time, interval_seconds)



def write_snapshot_to_csv(airplanes, filename, output_path, transcriptions, interval_seconds, start_time_str, end_time_str):
    print(f"Writing snapshot to {output_path}/{filename}...")
    os.makedirs(output_path, exist_ok=True)

    start_datetime = datetime.strptime(start_time_str, '%H%M%SZ')
    end_datetime = datetime.strptime(end_time_str, '%H%M%SZ')

    # Generate all time intervals within the range
    time_intervals = [start_datetime + timedelta(seconds=i * interval_seconds) for i in range((end_datetime - start_datetime).seconds // interval_seconds + 1)]

    # Create a dictionary to store rows by time
    rows_by_time = {}

    for current_time in time_intervals:
        current_time_str = current_time.strftime('%H%M%SZ')
        time_range_start = current_time - timedelta(seconds=interval_seconds)
        time_range_end = current_time

        # Filter airplanes that are present within the time range
        filtered_airplanes = [airplane for airplane in airplanes if time_range_start <= datetime.strptime(airplane.time, '%H%M%SZ') <= time_range_end]

        # Initialize a row for this time if not already present
        if current_time_str not in rows_by_time:
            rows_by_time[current_time_str] = {
                'DT Time': current_time_str,
                'Aircraft(Obj)': [],
                'ATIS Transcription Start': [],
                'ATIS Transcription End': [],
                'ATIS Transcription Text': [],
                'Approach/Departure Transcription Start': [],
                'Approach/Departure Transcription End': [],
                'Approach/Departure Transcription Text': [],
                'TOWER Transcription Start': [],
                'TOWER Transcription End': [],
                'TOWER Transcription Text': []
            }

        # Add data for each airplane, ensuring no duplicate entries
        for airplane in filtered_airplanes:
            existing_airplane = next((item for item in rows_by_time[current_time_str]['Aircraft(Obj)'] if item['Hex'] == airplane.hex), None)
            if not existing_airplane:
                rows_by_time[current_time_str]['Aircraft(Obj)'].append(airplane.to_dict())

        # Collect all transcriptions that fall within the overall time range
        for source, trans_list in transcriptions.items():
            for trans in trans_list:
                if trans.start <= current_time.time() <= trans.end:
                    rows_by_time[current_time_str][f'{source} Transcription Start'].append(str(trans.start))
                    rows_by_time[current_time_str][f'{source} Transcription End'].append(str(trans.end))
                    rows_by_time[current_time_str][f'{source} Transcription Text'].append(f'"{trans.transcription_text}"')

    # Write to CSV
    with open(os.path.join(output_path, filename), 'w', newline='') as file:
        writer = csv.writer(file, quotechar='"', quoting=csv.QUOTE_MINIMAL)
        headers = [
            'DT Time',
            'Aircraft(Obj)',
            'ATIS Transcription Start',
            'ATIS Transcription End',
            'ATIS Transcription Text',
            'Approach/Departure Transcription Start',
            'Approach/Departure Transcription End',
            'Approach/Departure Transcription Text',
            'TOWER Transcription Start',
            'TOWER Transcription End',
            'TOWER Transcription Text'
        ]
        writer.writerow(headers)  # Write header

        # Initial row with default values
        initial_row = [
            '000000Z',  # DT Time
            '[]',       # Aircraft(Obj)
            'None',     # ATIS Transcription Start
            'None',     # ATIS Transcription End
            'None',     # ATIS Transcription Text
            'None',     # Approach/Departure Transcription Start
            'None',     # Approach/Departure Transcription End
            'None',     # Approach/Departure Transcription Text
            'None',     # TOWER Transcription Start
            'None',     # TOWER Transcription End
            'None'      # TOWER Transcription Text
        ]
        writer.writerow(initial_row)  # Write initial row

        for time_key in sorted(rows_by_time.keys()):
            data = rows_by_time[time_key]

            # Prepare row data
            row = [
                data['DT Time'],
                json.dumps(data['Aircraft(Obj)']),  # JSON formatted
                ', '.join(data['ATIS Transcription Start']),
                ', '.join(data['ATIS Transcription End']),
                ' | '.join(data['ATIS Transcription Text']),
                ', '.join(data['Approach/Departure Transcription Start']),
                ', '.join(data['Approach/Departure Transcription End']),
                ' | '.join(data['Approach/Departure Transcription Text']),
                ', '.join(data['TOWER Transcription Start']),
                ', '.join(data['TOWER Transcription End']),
                ' | '.join(data['TOWER Transcription Text'])
            ]

            # Ensure no data is printed outside its columns
            row = [field if field else '' for field in row]  # Replace None with empty string
            writer.writerow(row)


# Main Execution

def main():
    transcription_files = [
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/new_freq_filesWAV2TXT - KGSO_ATIS 2_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/new_freq_filesWAV2TXT - KGSO_Approach_Departure 2_reformatted.csv',
        '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/new_freq_filesWAV2TXT - KGSO_TOWER 2_reformatted.csv'
    ]

    # Load transcriptions
    transcriptions = load_transcriptions_from_csv(transcription_files)

    csv_file = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data/adsb_hist_06_01_24_cleaned.csv'
    # Load airplanes
    airplanes = load_airplanes_from_csv(csv_file)

    start_time_str = input("Enter start time (e.g., 000000Z): ").strip()
    end_time_str = input("Enter end time (e.g., 010000Z): ").strip()
    interval_str = input("Enter time interval (e.g., 30s, 1m): ").strip()
    speed_str = input("Enter execution speed (e.g., 1.0 for normal speed): ").strip()

    try:
        start_time = datetime.strptime(start_time_str, '%H%M%SZ')
        end_time = datetime.strptime(end_time_str, '%H%M%SZ')
        interval = int(interval_str[:-1])
        if interval_str[-1] == 'm':
            interval *= 60
        elif interval_str[-1] == 's':
            pass
        else:
            raise ValueError("Interval should be in 's' or 'm'.")
        speed = float(speed_str)
        interval_seconds = interval

        time_points = [start_time + timedelta(seconds=i * interval) for i in range((end_time - start_time).seconds // interval + 1)]

        output_path = '/content/drive/MyDrive/ATC_Transponder_Data/sim_test1_data'
        all_filtered_airplanes = []

        for current_time in time_points:
            print(f"\nCurrent Simulation Time: {current_time.strftime('%H%M%SZ')}")
            filtered_airplanes = [
                airplane for airplane in airplanes
                if abs((datetime.strptime(airplane.time, '%H%M%SZ') - current_time).total_seconds()) <= interval_seconds
            ]

            simulate_data_update(filtered_airplanes, current_time, interval_seconds)
            all_filtered_airplanes.extend(filtered_airplanes)  # Collect data

            # Optional: print details of airplanes for current time
            for idx, airplane in enumerate(filtered_airplanes, 1):
                print(f"\nAirplane {idx}:")
                print(f"Time: {airplane.time}")
                print(f"Hex: {airplane.hex}")
                print(f"Distance to GSO: {airplane.dist_to_gso}")
                print(f"Data Source Type: {airplane.ds_type}")
                print(f"Flight Number: {airplane.flight_number}")
                print(f"Aircraft Registration: {airplane.aircraft_reg}")
                print(f"Aircraft Type: {airplane.aircraft_type}")
                print(f"Altitude Barometric: {airplane.altitude_baro}")
                print(f"Altitude Geometric: {airplane.altitude_geom}")
                print(f"Ground Speed: {airplane.ground_speed}")
                print(f"Track: {airplane.track}")
                print(f"Barometric Rate: {airplane.baro_rate}")
                print(f"Squawk Code: {airplane.squawk}")
                print(f"Emergency: {airplane.emergency}")
                print(f"Category: {airplane.category}")
                print(f"Latitude: {airplane.latitude}")
                print(f"Longitude: {airplane.longitude}")
                print(f"NIC Navigation Integrity Category: {airplane.nic_navigation}")
                print(f"RC Navigation Accuracy Category: {airplane.rc_navigation}")
                print(f"Seen Position: {airplane.seen_position}")
                print(f"Version: {airplane.version}")
                print(f"NIC Baro: {airplane.nic_baro}")
                print(f"NAC P: {airplane.nac_p}")
                print(f"NAC V: {airplane.nac_v}")
                print(f"SIL Source Integrity Level: {airplane.sil_level}")
                print(f"SIL Type: {airplane.sil_type}")
                print(f"GVA: {airplane.gva}")
                print(f"SDA System Design Assurance: {airplane.sda}")
                print(f"Alert: {airplane.alert}")
                print(f"SPI: {airplane.spi}")
                print(f"MLAT: {airplane.mlat}")
                print(f"TISB: {airplane.tisb}")
                print(f"Messages: {airplane.messages}")
                print(f"Seen: {airplane.seen}")
                print(f"RSSI: {airplane.rssi}")

                transcriptions_for_airplane = TranscriptionHandler.get_transcriptions(airplane, transcriptions)
                for source, texts in transcriptions_for_airplane.items():
                    for trans in texts:
                        print(f"\n{source} Transcription:")
                        print(f"Filename: {trans.filename}")
                        print(f"Start: {trans.start}")
                        print(f"End: {trans.end}")
                        print(f"Transcription: {trans.transcription_text}")

            time.sleep(interval_seconds / speed)

        # Save the final snapshot after the simulation
        snapshot_file = 'snapshot_final.csv'
        write_snapshot_to_csv(all_filtered_airplanes, snapshot_file, output_path, transcriptions, interval_seconds, start_time_str, end_time_str)
        print(f"Final snapshot saved to {output_path}/{snapshot_file}")

    except ValueError as e:
        print(f"Error in input data: {e}")

    print("Simulation completed.")

if __name__ == "__main__":
    main()